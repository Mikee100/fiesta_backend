import { Queue } from 'bull';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../prisma/prisma.service';
import { BookingsService } from '../bookings/bookings.service';
import { MessagesService } from '../messages/messages.service';
import { EscalationService } from '../escalation/escalation.service';
import { CircuitBreakerService } from './services/circuit-breaker.service';
import { NotificationsService } from '../notifications/notifications.service';
import { WebsocketGateway } from '../../websockets/websocket.gateway';
type HistoryMsg = {
    role: 'user' | 'assistant';
    content: string;
};
import { CustomerMemoryService } from './services/customer-memory.service';
import { ConversationLearningService } from './services/conversation-learning.service';
import { DomainExpertiseService } from './services/domain-expertise.service';
import { AdvancedIntentService } from './services/advanced-intent.service';
import { PersonalizationService } from './services/personalization.service';
import { FeedbackLoopService } from './services/feedback-loop.service';
import { PredictiveAnalyticsService } from './services/predictive-analytics.service';
export declare class AiService {
    private configService;
    private prisma;
    private circuitBreaker;
    private customerMemory;
    private conversationLearning;
    private domainExpertise;
    private advancedIntent;
    private personalization;
    private feedbackLoop;
    private predictiveAnalytics;
    private bookingsService?;
    private messagesService?;
    private escalationService?;
    private aiQueue?;
    private notificationsService?;
    private websocketGateway?;
    extractDateTime(text: string): Promise<Date | null>;
    private getOrdinalSuffix;
    private readonly logger;
    private openai;
    private pinecone;
    private index;
    private strategies;
    private formatPackageDetails;
    private readonly embeddingModel;
    private readonly extractorModel;
    private readonly chatModel;
    private readonly maxRetries;
    private readonly baseRetryDelay;
    private readonly maxRetryDelay;
    private readonly chatModelFallbackChain;
    private readonly maxContextTokens;
    private readonly summaryThreshold;
    private tokenEncoding;
    private readonly studioTz;
    private readonly historyLimit;
    private readonly maxTokensPerDay;
    private tokenUsageCache;
    private packageCache;
    private readonly CACHE_TTL;
    private semanticCache;
    private readonly SEMANTIC_CACHE_TTL;
    private readonly businessName;
    private readonly businessLocation;
    private readonly businessWebsite;
    private readonly customerCarePhone;
    private readonly customerCareEmail;
    private readonly businessHours;
    constructor(configService: ConfigService, prisma: PrismaService, circuitBreaker: CircuitBreakerService, customerMemory: CustomerMemoryService, conversationLearning: ConversationLearningService, domainExpertise: DomainExpertiseService, advancedIntent: AdvancedIntentService, personalization: PersonalizationService, feedbackLoop: FeedbackLoopService, predictiveAnalytics: PredictiveAnalyticsService, bookingsService?: BookingsService, messagesService?: MessagesService, escalationService?: EscalationService, aiQueue?: Queue, notificationsService?: NotificationsService, websocketGateway?: WebsocketGateway);
    private initializeTokenEncoding;
    private checkAndEscalateIfHandoffMentioned;
    createEscalationAlert(customerId: string, type: 'reschedule_request' | 'ai_escalation', title: string, message: string, metadata?: any): Promise<void>;
    private checkAndCreateSessionNote;
    private initPineconeSafely;
    private checkRateLimit;
    private trackTokenUsage;
    private getTokenCount;
    private calculateTokenCount;
    private pruneHistory;
    private generateClarifyingQuestion;
    private summarizeOldMessages;
    private retryOpenAICall;
    private handleOpenAIFailure;
    private detectFrustration;
    getCachedPackages(): Promise<any[]>;
    private sanitizeInput;
    private retryOperation;
    private validatePhoneNumber;
    private checkBookingConflicts;
    trackConversationMetrics(customerId: string, metrics: {
        intent: string;
        duration: number;
        messagesCount: number;
        resolved: boolean;
    }): Promise<void>;
    normalizeDateTime(rawDate?: string | null, rawTime?: string | null): {
        isoUtc: string;
        dateOnly: string;
        timeOnly: string;
    };
    generateEmbedding(text: string): Promise<number[]>;
    retrieveRelevantDocs(query: string, topK?: number): Promise<any[]>;
    private searchByKeywords;
    private searchByVector;
    private searchByFuzzy;
    private rankAndScoreResults;
    private normalizeQueryForCache;
    private cleanSemanticCache;
    answerFaq(question: string, history?: HistoryMsg[], actual?: string, customerId?: string, enrichedContext?: any): Promise<{
        text: string;
        mediaUrls: string[];
    }>;
    extractBookingDetails(message: string, history?: HistoryMsg[]): Promise<{
        service?: string;
        date?: string;
        time?: string;
        name?: string;
        recipientName?: string;
        recipientPhone?: string;
        isForSomeoneElse?: boolean;
        subIntent: 'start' | 'provide' | 'confirm' | 'cancel' | 'unknown';
    }>;
    private generateBookingReply;
    getOrCreateDraft(customerId: string): Promise<{
        id: string;
        customerId: string;
        service: string | null;
        date: string | null;
        time: string | null;
        dateTimeIso: string | null;
        name: string | null;
        recipientName: string | null;
        recipientPhone: string | null;
        isForSomeoneElse: boolean | null;
        step: string;
        conflictResolution: string | null;
        bookingId: string | null;
        version: number;
        createdAt: Date;
        updatedAt: Date;
    }>;
    mergeIntoDraft(customerId: string, extraction: any): Promise<{
        id: string;
        customerId: string;
        service: string | null;
        date: string | null;
        time: string | null;
        dateTimeIso: string | null;
        name: string | null;
        recipientName: string | null;
        recipientPhone: string | null;
        isForSomeoneElse: boolean | null;
        step: string;
        conflictResolution: string | null;
        bookingId: string | null;
        version: number;
        createdAt: Date;
        updatedAt: Date;
    }>;
    checkAndCompleteIfConfirmed(draft: any, extraction: any, customerId: string, bookingsService: any): Promise<{
        action: string;
        error: string;
        message?: undefined;
        suggestions?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
        missing?: undefined;
    } | {
        action: string;
        message: string;
        suggestions: string[];
        error?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
        missing?: undefined;
    } | {
        action: string;
        suggestions: any;
        error?: undefined;
        message?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
        missing?: undefined;
    } | {
        action: string;
        message: any;
        amount: any;
        packageName: any;
        checkoutRequestId: any;
        paymentId: any;
        error?: undefined;
        suggestions?: undefined;
        missing?: undefined;
    } | {
        action: string;
        message: string;
        error?: undefined;
        suggestions?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
        missing?: undefined;
    } | {
        action: string;
        amount: any;
        packageName: any;
        error?: undefined;
        message?: undefined;
        suggestions?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
        missing?: undefined;
    } | {
        action: string;
        missing: any[];
        error?: undefined;
        message?: undefined;
        suggestions?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
    }>;
    confirmCustomerPhone(customerId: string): Promise<boolean>;
    handleConversation(message: string, customerId: string, history?: HistoryMsg[], bookingsService?: any, retryCount?: number, enrichedContext?: any): Promise<any>;
    private attemptRecovery;
    private processConversationLogic;
    addKnowledge(question: string, answer: string, category?: string): Promise<void>;
    processAiRequest(data: {
        question: string;
    }): Promise<{
        text: string;
        mediaUrls: string[];
    }>;
    generateResponse(message: string, customerId: string, bookingsService: any, history?: any[], extractedBooking?: any, faqContext?: string): Promise<string>;
    extractStepBasedBookingDetails(message: string, currentStep: string, history?: any[]): Promise<any>;
    generateStepBasedBookingResponse(message: string, customerId: string, bookingsService: any, history: any[], draft: any, bookingResult: any): Promise<string>;
    generateGeneralResponse(message: string, customerId: string, bookingsService: any, history?: any[]): Promise<string>;
    handleConversationWithLearning(message: string, customerId: string, history?: any[], bookingsService?: any, retryCount?: number, enrichedContext?: any): Promise<any>;
}
export {};

import { Queue } from 'bull';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../../prisma/prisma.service';
import { BookingsService } from '../bookings/bookings.service';
import { MessagesService } from '../messages/messages.service';
import { EscalationService } from '../escalation/escalation.service';
import { CircuitBreakerService } from './services/circuit-breaker.service';
type HistoryMsg = {
    role: 'user' | 'assistant';
    content: string;
};
export declare class AiService {
    private configService;
    private prisma;
    private circuitBreaker;
    private bookingsService?;
    private messagesService?;
    private escalationService?;
    private aiQueue?;
    private readonly logger;
    private openai;
    private pinecone;
    private index;
    private strategies;
    private readonly embeddingModel;
    private readonly extractorModel;
    private readonly chatModel;
    private readonly studioTz;
    private readonly historyLimit;
    private readonly maxTokensPerDay;
    private tokenUsageCache;
    private packageCache;
    private readonly CACHE_TTL;
    private readonly businessName;
    private readonly businessLocation;
    private readonly businessWebsite;
    private readonly customerCarePhone;
    private readonly customerCareEmail;
    private readonly businessHours;
    constructor(configService: ConfigService, prisma: PrismaService, circuitBreaker: CircuitBreakerService, bookingsService?: BookingsService, messagesService?: MessagesService, escalationService?: EscalationService, aiQueue?: Queue);
    private initPineconeSafely;
    private checkRateLimit;
    private trackTokenUsage;
    private calculateTokenCount;
    private pruneHistory;
    private handleOpenAIFailure;
    private detectFrustration;
    getCachedPackages(): Promise<any[]>;
    private sanitizeInput;
    private validatePhoneNumber;
    private checkBookingConflicts;
    trackConversationMetrics(customerId: string, metrics: {
        intent: string;
        duration: number;
        messagesCount: number;
        resolved: boolean;
    }): Promise<void>;
    normalizeDateTime(rawDate?: string | null, rawTime?: string | null): {
        isoUtc: string;
        dateOnly: string;
        timeOnly: string;
    };
    generateEmbedding(text: string): Promise<number[]>;
    retrieveRelevantDocs(query: string, topK?: number): Promise<any>;
    private formatPackageDetails;
    answerFaq(question: string, history?: HistoryMsg[], actual?: string, customerId?: string, enrichedContext?: any): Promise<{
        text: string;
        mediaUrls: string[];
    }>;
    extractBookingDetails(message: string, history?: HistoryMsg[]): Promise<{
        service?: string;
        date?: string;
        time?: string;
        name?: string;
        recipientName?: string;
        recipientPhone?: string;
        isForSomeoneElse?: boolean;
        subIntent: 'start' | 'provide' | 'confirm' | 'cancel' | 'unknown';
    }>;
    private generateBookingReply;
    getOrCreateDraft(customerId: string): Promise<{
        id: string;
        createdAt: Date;
        updatedAt: Date;
        name: string | null;
        customerId: string;
        service: string | null;
        date: string | null;
        time: string | null;
        dateTimeIso: string | null;
        recipientName: string | null;
        recipientPhone: string | null;
        isForSomeoneElse: boolean | null;
        step: string;
        conflictResolution: string | null;
        version: number;
    }>;
    mergeIntoDraft(customerId: string, extraction: any): Promise<{
        id: string;
        createdAt: Date;
        updatedAt: Date;
        name: string | null;
        customerId: string;
        service: string | null;
        date: string | null;
        time: string | null;
        dateTimeIso: string | null;
        recipientName: string | null;
        recipientPhone: string | null;
        isForSomeoneElse: boolean | null;
        step: string;
        conflictResolution: string | null;
        version: number;
    }>;
    checkAndCompleteIfConfirmed(draft: any, extraction: any, customerId: string, bookingsService: any): Promise<{
        action: string;
        error: string;
        message?: undefined;
        suggestions?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
        missing?: undefined;
    } | {
        action: string;
        message: string;
        suggestions: string[];
        error?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
        missing?: undefined;
    } | {
        action: string;
        suggestions: any;
        error?: undefined;
        message?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
        missing?: undefined;
    } | {
        action: string;
        message: any;
        amount: any;
        packageName: any;
        checkoutRequestId: any;
        paymentId: any;
        error?: undefined;
        suggestions?: undefined;
        missing?: undefined;
    } | {
        action: string;
        missing: any[];
        error?: undefined;
        message?: undefined;
        suggestions?: undefined;
        amount?: undefined;
        packageName?: undefined;
        checkoutRequestId?: undefined;
        paymentId?: undefined;
    }>;
    confirmCustomerPhone(customerId: string): Promise<boolean>;
    handleConversation(message: string, customerId: string, history?: HistoryMsg[], bookingsService?: any, retryCount?: number, enrichedContext?: any): Promise<any>;
    private attemptRecovery;
    private processConversationLogic;
    addKnowledge(question: string, answer: string): Promise<void>;
    processAiRequest(data: {
        question: string;
    }): Promise<{
        text: string;
        mediaUrls: string[];
    }>;
    generateResponse(message: string, customerId: string, bookingsService: any, history?: any[], extractedBooking?: any, faqContext?: string): Promise<string>;
    extractStepBasedBookingDetails(message: string, currentStep: string, history?: any[]): Promise<any>;
    generateStepBasedBookingResponse(message: string, customerId: string, bookingsService: any, history: any[], draft: any, bookingResult: any): Promise<string>;
    generateGeneralResponse(message: string, customerId: string, bookingsService: any, history?: any[]): Promise<string>;
}
export {};
